                    ---------数组中的逆序对

--题目描述：
  在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

--输入：
  每个测试案例包括两行：
  第一行包含一个整数n，表示数组中的元素个数。其中1 <= n <= 10^5。
  第二行包含n个整数，每个数组均为int类型。

--输出：
  对应每个测试案例，输出一个整数，表示数组中的逆序对的总数。

--样例输入：
  4
  7 5 6 4

--样例输出：
  5

--解题思路:

  看到这样的题目，最简单的想法就是遍历每一个元素，让其与后面的元素对比，如果大于则count++，但是这样的时间复杂度是o(n2)。
  这题有更好的解决方法，时间复杂度只需要o(nlogn)。其实这道题目的思路跟归并排序差不多，求逆序对的过程就是一个求归并排序的过程，
  在求出逆序对以后，原数组变得有序，是通过归并排序得到的。

 （1）总体的意思就是将数组分成两段，首先求段内的逆序对数量，比如下面两段代码就是求左右两端数组段内的逆序对数量

     inversions+=InversePairsCore(arry,start,mid,temp);//找左半段的逆序对数目
     inversions+=InversePairsCore(arry,mid+1,end,temp);//找右半段的逆序对数目

 （2）然后求段间的逆序对数量，如下面的代码

     inversions+=MergeArray(arry,start,mid,end,temp);//在找完左右半段逆序对以后两段数组有序，然后找两段之间的逆序对。最小的逆序段只有一个元素。

 （3）然后在求段间逆序对的时候，我们分为arry[start...mid]和arry[mid+1...end]，然后设置两个指针ij分别指向两段数组的末尾元素，也就是i=mid，j=end。
     然后比较arry[i]和arry[j]，

     如果arry[i]>arry[j]，因为两段数组都是有序的，所以arry[i]>arry[mid+1...j]，这些都是逆序对，我们统计出的逆序对为j-(mid+1)+1=j-mid。
     并且将大数arry[i]放入临时数组temp[]当中，i往前移动
     
     如果arry[i]<arry[j]，则将大数arry[j]放入temp[]中，j往前移。
