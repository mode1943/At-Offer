题目描述：
   --给定一棵树，同时给出树中的两个结点，求它们的最低公共祖先。

输入：
   --输入可能包含多个测试样例。
     对于每个测试案例，输入的第一行为一个数n(0<n<1000)，代表测试样例的个数。
     其中每个测试样例包括两行，第一行为一个二叉树的先序遍历序列，其中左右子树若为空则用0代替，其中二叉树的结点个数node_num<10000。
     第二行为树中的两个结点的值m1与m2(0<m1,m2<10000)。

输出：
   --对应每个测试案例，
     输出给定的树中两个结点的最低公共祖先结点的值，若两个给定结点无最低公共祖先，则输出“My God”。

样例输入：
   2
   1 2 4 6 0 0 7 0 0 5 8 0 0 9 0 0 3 0 0
   6 8
   1 2 4 6 0 0 7 0 0 5 8 0 0 9 0 0 3 0 0
   6 12

样例输出：
   2
   My God
这类的题目，方法蛮多的，思路也不难理解，基本都是各种遍历的变种，主要是写代码，尤其基于递归的代码。
首先如果是二叉排序树自然不用说了，判断的一句就是该节点的值是否位于输入的这两个节点之间，可以用前序遍历来做。
如果是普通的树或者二叉树，解题思路是一样的，可以考虑前序遍历，得到两个路径，用链表或数组保存起来，然后找出两条路径的最后一个公共节点即可。也可以后序遍历的方式，遍历到输入的节点时，将该节点及其后面遍历到的节点都保存到一个链表或数组中，然后找出两条路径的第一个公共机节点即可。
 下面采用的是前序遍历，并用数组保存路径的代码。
